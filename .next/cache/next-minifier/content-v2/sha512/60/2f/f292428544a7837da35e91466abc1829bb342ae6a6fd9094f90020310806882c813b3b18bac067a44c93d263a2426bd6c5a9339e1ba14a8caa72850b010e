{"code":"_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[9],{\"20a2\":function(e,r,t){e.exports=t(\"nOHt\")},O2ls:function(e,r,t){\"use strict\";t.r(r);var n=t(\"q1tI\"),a=t.n(n),s=function(e){var r=e.children;return a.a.createElement(\"div\",{className:\"mx-auto grid gap-4\"},r)},i=e=>\"checkbox\"===e.type,c=e=>null==e;const o=e=>\"object\"===typeof e;var u=e=>!c(e)&&!Array.isArray(e)&&o(e)&&!(e instanceof Date),l=e=>e.substring(0,e.search(/.\\d/))||e,d=e=>e.filter(Boolean),f=e=>void 0===e,m=(e={},r,t)=>{const n=d(r.split(/[,[\\].]+?/)).reduce(((e,r)=>c(e)?e:e[r]),e);return f(n)||n===e?f(e[r])?t:e[r]:n};const h=\"blur\",g=\"onBlur\",b=\"onChange\",y=\"onSubmit\",p=\"onTouched\",v=\"all\",w=\"undefined\",k=\"max\",O=\"min\",D=\"maxLength\",j=\"minLength\",S=\"pattern\",x=\"required\",A=\"validate\";var V=(e,r)=>{const t=Object.assign({},e);return delete t[r],t};const _=n.createContext(null);_.displayName=\"RHFContext\";const E=()=>n.useContext(_),R=e=>n.createElement(_.Provider,{value:V(e,\"children\")},e.children);var C=(e,r,t,n,a=!0)=>e?new Proxy(r,{get:(e,r)=>{if(r in e)return t.current[r]!==v&&(t.current[r]=!a||v),n&&(n.current[r]=!0),e[r]}}):r,T=e=>u(e)&&!Object.keys(e).length,F=(e,r,t)=>T(e)||Object.keys(e).length>=Object.keys(r).length||Object.keys(e).find((e=>r[e]===(!t||v))),I=typeof window!==w&&typeof window.HTMLElement!==w&&typeof document!==w;const N=I?\"Proxy\"in window:typeof Proxy!==w;var B=(e,r,t,n,a)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:a||!0})}):{},L=e=>/^\\w*$/.test(e),q=e=>d(e.replace(/[\"|']|\\]/g,\"\").split(/\\.|\\[/));function M(e,r,t){let n=-1;const a=L(r)?[r]:q(r),s=a.length,i=s-1;for(;++n<s;){const r=a[n];let s=t;if(n!==i){const t=e[r];s=u(t)||Array.isArray(t)?t:isNaN(+a[n+1])?{}:[]}e[r]=s,e=e[r]}return e}const P=(e,r,t)=>{for(const n of t||Object.keys(e)){const t=m(e,n);if(t){const e=t._f,n=V(t,\"_f\");if(e&&r(e.name)){if(e.ref.focus&&f(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else u(n)&&P(n,r)}}},z=(e,r={current:{}},t={})=>{for(const n in e.current){const a=e.current[n];if(a){const e=a._f,s=V(a,\"_f\");M(t,n,e?e.ref.disabled||e.refs&&e.refs.every((e=>e.disabled))?void 0:e.value:Array.isArray(a)?[]:{}),s&&z({current:s},r,t[n])}}return Object.assign(Object.assign({},r.current),t)};var U=e=>c(e)||!o(e);function H(e,r,t){if(U(e)||U(r)||e instanceof Date||r instanceof Date)return e===r;if(!n.isValidElement(e)){const n=Object.keys(e),a=Object.keys(r);if(n.length!==a.length)return!1;for(const s of n){const n=e[s];if(!t||\"ref\"!==s){const e=r[s];if((u(n)||Array.isArray(n))&&(u(e)||Array.isArray(e))?!H(n,e,t):n!==e)return!1}}}return!0}function J(e,r){if(U(e)||U(r))return r;for(const n in r){const a=e[n],s=r[n];try{e[n]=u(a)&&u(s)||Array.isArray(a)&&Array.isArray(s)?J(a,s):s}catch(t){}}return e}function W(e,r,t,n,a){let s=-1;for(;++s<e.length;){for(const n in e[s])Array.isArray(e[s][n])?(!t[s]&&(t[s]={}),t[s][n]=[],W(e[s][n],m(r[s]||{},n,[]),t[s][n],t[s],n)):H(m(r[s]||{},n),e[s][n])?M(t[s]||{},n):t[s]=Object.assign(Object.assign({},t[s]),{[n]:!0});n&&!t.length&&delete n[a]}return t}var K=(e,r,t)=>J(W(e,r,t.slice(0,e.length)),W(r,e,t.slice(0,e.length)));var $=e=>\"boolean\"===typeof e;function X(e,r){const t=L(r)?[r]:q(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=f(e)?n++:e[r[n++]];return e}(e,t),a=t[t.length-1];let s;n&&delete n[a];for(let i=0;i<t.slice(0,-1).length;i++){let r,n=-1;const a=t.slice(0,-(i+1)),c=a.length-1;for(i>0&&(s=e);++n<a.length;){const t=a[n];r=r?r[t]:e[t],c===n&&(u(r)&&T(r)||Array.isArray(r)&&!r.filter((e=>u(e)&&!T(e)||$(e))).length)&&(s?delete s[t]:delete e[t]),s=r}}return e}function Y(e,r){const t={};for(const n of e){const e=m(r,n);e&&(L(n)?t[n]=e._f:M(t,n,e._f))}return t}var G=e=>\"file\"===e.type,Q=e=>\"select-multiple\"===e.type,Z=e=>\"radio\"===e.type;const ee={value:!1,isValid:!1},re={value:!0,isValid:!0};var te=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:r,isValid:!!r.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!f(e[0].attributes.value)?f(e[0].value)||\"\"===e[0].value?re:{value:e[0].value,isValid:!0}:re:ee}return ee};const ne={isValid:!1,value:null};var ae=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.checked&&!r.disabled?{isValid:!0,value:r.value}:e),ne):ne;function se(e){if(e&&e._f){const t=e._f.ref;if(t.disabled)return;return G(t)?t.files:Z(t)?ae(e._f.refs).value:Q(t)?(r=t.options,[...r].filter((({selected:e})=>e)).map((({value:e})=>e))):i(t)?te(e._f.refs).value:((e,{valueAsNumber:r,valueAsDate:t,setValueAs:n})=>r?\"\"===e?NaN:+e:t?new Date(e):n?n(e):e)(f(t.value)?e._f.ref.value:t.value,e._f)}var r}var ie=e=>e&&(e.required||e.min||e.max||e.maxLength||e.minLength||e.pattern||e.validate),ce=e=>\"function\"===typeof e,oe=e=>\"string\"===typeof e,ue=e=>oe(e)||n.isValidElement(e),le=e=>e instanceof RegExp;function de(e,r,t=\"validate\"){if(ue(e)||$(e)&&!e)return{type:t,message:ue(e)?e:\"\",ref:r}}var fe=e=>u(e)&&!le(e)?e:{value:e,message:\"\"},me=async({_f:{ref:e,refs:r,required:t,maxLength:n,minLength:a,min:s,max:o,pattern:l,validate:d,name:f,value:m,valueAsNumber:h}},g)=>{const b={},y=Z(e),p=i(e),v=y||p,w=(h||G(e))&&!e.value||\"\"===m||Array.isArray(m)&&!m.length,V=B.bind(null,f,g,b),_=(r,t,n,a=D,s=j)=>{const i=r?t:n;b[f]=Object.assign({type:r?a:s,message:i,ref:e},V(r?a:s,i))};if(t&&(!y&&!p&&(w||c(m))||$(m)&&!m||p&&!te(r).isValid||y&&!ae(r).isValid)){const{value:n,message:a}=ue(t)?{value:!!t,message:t}:fe(t);if(n&&(b[f]=Object.assign({type:x,message:a,ref:v?(r||[])[0]||{}:e},V(x,a)),!g))return b}if((!c(s)||!c(o))&&\"\"!==m){let r,t;const n=fe(o),a=fe(s);if(isNaN(m)){const s=e.valueAsDate||new Date(m);oe(n.value)&&(r=s>new Date(n.value)),oe(a.value)&&(t=s<new Date(a.value))}else{const s=e.valueAsNumber||parseFloat(m);c(n.value)||(r=s>n.value),c(a.value)||(t=s<a.value)}if((r||t)&&(_(!!r,n.message,a.message,k,O),!g))return b}if(oe(m)&&!w&&(n||a)){const e=fe(n),r=fe(a),t=!c(e.value)&&m.length>e.value,s=!c(r.value)&&m.length<r.value;if((t||s)&&(_(t,e.message,r.message),!g))return b}if(oe(m)&&l&&!w){const{value:r,message:t}=fe(l);if(le(r)&&!m.match(r)&&(b[f]=Object.assign({type:S,message:t,ref:e},V(S,t)),!g))return b}if(d){const t=v&&r?r[0]:e;if(ce(d)){const e=de(await d(m),t);if(e&&(b[f]=Object.assign(Object.assign({},e),V(A,e.message)),!g))return b}else if(u(d)){let e={};for(const[r,n]of Object.entries(d)){if(!T(e)&&!g)break;const a=de(await n(m),t,r);a&&(e=Object.assign(Object.assign({},a),V(r,a.message)),g&&(b[f]=e))}if(!T(e)&&(b[f]=Object.assign({ref:t},e),!g))return b}}return b},he=e=>({isOnSubmit:!e||e===y,isOnBlur:e===g,isOnChange:e===b,isOnAll:e===v,isOnTouch:e===p}),ge=e=>e instanceof HTMLElement;class be{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class ye{constructor(e,r){this.observer=e,this.closed=!1,r.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class pe{constructor(){this.observers=[]}next(e){for(const r of this.observers)r.next(e)}subscribe(e){const r=new be,t=new ye(e,r);return this.observers.push(t),r}unsubscribe(){this.observers=[]}}const ve=typeof window===w;function we({mode:e=y,reValidateMode:r=b,resolver:t,context:a,defaultValues:s={},shouldFocusError:o=!0,shouldUnregister:u=!1,criteriaMode:g}={}){const p=n.useRef({}),w=n.useRef(new Set),k=n.useRef(new pe),O=n.useRef(new pe),D=n.useRef(new pe),j=n.useRef(new pe),S=n.useRef({}),x=n.useRef(new Set),A=n.useRef(!1),_=n.useRef({}),E=n.useRef({}),R=n.useRef(s),B=n.useRef(!1),L=n.useRef(a),q=n.useRef(t),U=n.useRef(new Set),J=he(e),W=g===v,[$,ee]=n.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!J.isOnSubmit,errors:{}}),re=n.useRef({isDirty:!N,dirtyFields:!N,touchedFields:!N,isValidating:!N,isValid:!N,errors:!N}),te=n.useRef($);L.current=a,q.current=t;const ne=()=>te.current.isValid=H(E.current,_.current)&&T(te.current.errors),ae=n.useCallback(((e,r,t=!1,n={},a,s)=>{const i=m(te.current.errors,e);let o=t||!H(i,r,!0)||re.current.isValid&&f(r)&&m(_.current,e)&&!m(E.current,e);if(r?(X(E.current,e),o=o||!i||!H(i,r,!0),M(te.current.errors,e,r)):((m(_.current,e)||q.current)&&(M(E.current,e,!0),o=o||i),X(te.current.errors,e)),o&&!c(t)||!T(n)||s){const e=Object.assign(Object.assign({},n),{isValid:q.current?!!a:ne(),errors:te.current.errors});te.current=Object.assign(Object.assign({},te.current),e),k.current.next(s?{}:e)}k.current.next({isValidating:!1})}),[]),ue=n.useCallback(((e,r,t={},n,a)=>{a&&Ee(e);const s=m(p.current,e,{})._f;if(s){const a=I&&ge(s.ref)&&c(r)?\"\":r;if(s.value=r,Z(s.ref)?(s.refs||[]).forEach((e=>e.checked=e.value===a)):G(s.ref)&&!oe(a)?s.ref.files=a:Q(s.ref)?[...s.ref.options].forEach((e=>e.selected=a.includes(e.value))):i(s.ref)&&s.refs?s.refs.length>1?s.refs.forEach((e=>e.checked=Array.isArray(a)?!!a.find((r=>r===e.value)):a===e.value)):s.refs[0].checked=!!a:s.ref.value=a,n){const t=z(p);M(t,e,r),D.current.next({values:Object.assign(Object.assign({},R.current),t),name:e})}t.shouldDirty&&de(e,a),t.shouldValidate&&we(e)}}),[]),le=n.useCallback(((e,r)=>{const t=z(p);return e&&r&&M(t,e,r),!H(t,R.current)}),[]),de=n.useCallback(((e,r,t=!0)=>{if(re.current.isDirty||re.current.dirtyFields){const n=!H(m(R.current,e),r),a=m(te.current.dirtyFields,e),s=te.current.isDirty;n?M(te.current.dirtyFields,e,!0):X(te.current.dirtyFields,e),te.current.isDirty=le();const i={isDirty:te.current.isDirty,dirtyFields:te.current.dirtyFields},c=re.current.isDirty&&s!==i.isDirty||re.current.dirtyFields&&a!==m(te.current.dirtyFields,e);return c&&t&&k.current.next(i),c?i:{}}return{}}),[]),fe=n.useCallback((async(e,r)=>{const t=(await me(m(p.current,e),W))[e];return ae(e,t,r),f(t)}),[W]),be=n.useCallback((async(e,r=[])=>{const{errors:t}=await q.current(z(p,R),L.current,{criteriaMode:g,names:r,fields:Y(w.current,p.current)});for(const n of e){const e=m(t,n);e?M(te.current.errors,n,e):X(te.current.errors,n)}return t}),[g]),ye=async e=>{for(const r in e){const t=e[r];if(t){const e=t._f,r=V(t,\"_f\");if(e){const r=await me(t,W);r[e.name]?(M(te.current.errors,e.name,r[e.name]),X(E.current,e.name)):m(_.current,e.name)&&(M(E.current,e.name,!0),X(te.current.errors,e.name))}r&&await ye(r)}}},we=n.useCallback((async e=>{const r=f(e)?Object.keys(p.current):Array.isArray(e)?e:[e];let t;k.current.next({isValidating:!0}),q.current?t=T(await be(r,f(e)?void 0:r)):f(e)?await ye(p.current):await Promise.all(r.map((async e=>await fe(e,null)))),k.current.next({errors:te.current.errors,isValidating:!1,isValid:q.current?t:ne()})}),[be,fe]),ke=n.useCallback(((e,r,t)=>Object.entries(r).forEach((([r,n])=>{const a=`${e}.${r}`,s=m(p.current,a);s&&!s._f?ke(a,n,t):ue(a,n,t,!0,!s)}))),[we]),Oe=e=>B.current||x.current.has(e)||x.current.has((e.match(/\\w+/)||[])[0]),De=(e,r,t,n)=>{const a=m(p.current,e),s=f(a._f.value)?m(R.current,e):a._f.value;return a&&!f(s)&&(t&&t.defaultChecked?a._f.value=se(a):ue(e,s)),(!f(s)||n)&&ie(r)&&!J.isOnSubmit&&a&&re.current.isValid&&me(a,W).then((r=>{T(r)?M(E.current,e,!0):X(E.current,e),te.current.isValid!==ne()&&ee(Object.assign(Object.assign({},te.current),{isValid:ne()}))})),s},je=n.useCallback((async({type:e,target:t,target:{value:n,type:a}})=>{let s,c,o=t.name;const u=m(p.current,o);if(u){let d=a?se(u):void 0;d=f(d)?n:d;const b=e===h,{isOnBlur:y,isOnChange:v}=he(r),w=!ie(u._f)&&!q.current||(({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:a,isReValidateOnChange:s,isBlurEvent:i,isSubmitted:c,isOnAll:o})=>!o&&(!c&&t?!(n||i):(c?a:e)?!i:!(c?s:r)||i))(Object.assign({isBlurEvent:b,isTouched:!!m(te.current.touchedFields,o),isSubmitted:te.current.isSubmitted,isReValidateOnBlur:y,isReValidateOnChange:v},J)),D=!b&&Oe(o);f(d)||(u._f.value=d);const j=de(o,u._f.value,!1);b&&!m(te.current.touchedFields,o)&&(M(te.current.touchedFields,o,!0),re.current.touchedFields&&(j.touchedFields=te.current.touchedFields));let S=!T(j)||D;if(w)return!b&&O.current.next({name:o,type:e,value:d}),S&&k.current.next(D?{}:j);if(k.current.next({isValidating:!0}),q.current){const{errors:e}=await q.current(z(p,R),L.current,{criteriaMode:g,fields:Y([o],p.current),names:[o]}),r=te.current.isValid;if(s=m(e,o),i(t)&&!s){const r=l(o),t=m(e,r,{});t.type&&t.message&&(s=t),(t||m(te.current.errors,r))&&(o=r)}c=T(e),r!==c&&(S=!0)}else s=(await me(u,W))[o];!b&&O.current.next({name:o,type:e,value:d}),ae(o,s,S,j,c,D)}}),[]),Se=e=>{const r=A.current?z(p,R):R.current;return f(e)?r:oe(e)?m(r,e):e.map((e=>m(r,e)))},xe=n.useCallback((async(e={})=>{const r=te.current.isValid;if(t){const{errors:r}=await q.current(Object.assign(Object.assign({},z(p,R)),e),L.current,{criteriaMode:g,fields:Y(w.current,p.current)});te.current.isValid=T(r)}else ne();r!==te.current.isValid&&k.current.next({isValid:te.current.isValid})}),[g]),Ae=n.useCallback(((e,r,t)=>{const n=Array.isArray(e),a=A.current?Se():f(r)?R.current:n?r||{}:{[e]:r};if(f(e))return t&&(B.current=!0),a;const s=[];for(const i of n?e:[e])t&&x.current.add(i),s.push(m(a,i));return n?s:s[0]}),[]),Ve=(e,r={},t)=>{for(const n of e?Array.isArray(e)?e:[e]:Object.keys(w.current))w.current.delete(n),U.current.delete(n),m(p.current,n)&&(r.keepIsValid||(X(_.current,n),X(E.current,n)),!r.keepError&&X(te.current.errors,n),!r.keepValue&&X(p.current,n),!r.keepDirty&&X(te.current.dirtyFields,n),!r.keepTouched&&X(te.current.touchedFields,n),!r.keepDefaultValue&&X(R.current,n),t&&O.current.next({name:n}));t&&(k.current.next(Object.assign(Object.assign(Object.assign({},te.current),r.keepDirty?{isDirty:le()}:{}),q.current?{}:{isValid:ne()})),!r.keepIsValid&&xe())},_e=(e,r,t)=>{let n=m(p.current,e);if(n){const a=(e=>Z(e)||i(e))(r);if(r===n._f.ref||I&&ge(n._f.ref)&&!ge(r)||a&&Array.isArray(n._f.refs)&&d(n._f.refs).find((e=>e===r)))return;n={_f:a?Object.assign(Object.assign({},n._f),{refs:[...d(n._f.refs||[]).filter((e=>ge(e)&&document.contains(e))),r],ref:{type:r.type,name:e}}):Object.assign(Object.assign({},n._f),{ref:r})},M(p.current,e,n);const s=De(e,t,r,!0);(a&&Array.isArray(s)?!H(m(p.current,e)._f.value,s):f(m(p.current,e)._f.value))&&(m(p.current,e)._f.value=se(m(p.current,e)))}},Ee=n.useCallback(((e,r)=>{const t=!m(p.current,e);return M(p.current,e,{_f:Object.assign(Object.assign(Object.assign({},t?{ref:{name:e}}:Object.assign({ref:(m(p.current,e)._f||{}).ref},m(p.current,e)._f)),{name:e}),r)}),ie(r)&&M(_.current,e,!0),w.current.add(e),t&&De(e,r),ve?{name:e}:{name:e,onChange:je,onBlur:je,ref:t=>t?_e(e,t,r):(u||r&&r.shouldUnregister)&&Ve(e)}}),[R.current]),Re=n.useCallback(((e,r)=>async t=>{t&&(t.preventDefault&&t.preventDefault(),t.persist&&t.persist());let n=Object.assign(Object.assign({},R.current),z(p,R));k.current.next({isSubmitting:!0});try{if(q.current){const{errors:e,values:r}=await q.current(n,L.current,{criteriaMode:g,fields:Y(w.current,p.current)});te.current.errors=e,n=r}else await ye(p.current);T(te.current.errors)&&Object.keys(te.current.errors).every((e=>m(n,e)))?(k.current.next({errors:{},isSubmitting:!0}),await e(n,t)):(r&&await r(te.current.errors,t),o&&P(p.current,(e=>m(te.current.errors,e)),w.current))}finally{te.current.isSubmitted=!0,k.current.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:T(te.current.errors),submitCount:te.current.submitCount+1,errors:te.current.errors})}}),[o,W,g]),Ce=n.useCallback((({keepErrors:e,keepDirty:r,keepIsSubmitted:t,keepTouched:n,keepIsValid:a,keepSubmitCount:s},i)=>{a||(E.current={},_.current={}),x.current=new Set,B.current=!1,k.current.next({submitCount:s?te.current.submitCount:0,isDirty:r?te.current.isDirty:!(!i||!le()),isSubmitted:!!t&&te.current.isSubmitted,isValid:a?te.current.isValid:!!xe(i),dirtyFields:r?te.current.dirtyFields:{},touchedFields:n?te.current.touchedFields:{},errors:e?te.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})}),[]);return n.useEffect((()=>{A.current=!0;const e=k.current.subscribe({next(e={}){F(e,re.current,!0)&&(te.current=Object.assign(Object.assign({},te.current),e),ee(te.current))}}),r=j.current.subscribe({next(e){if(e.fields&&e.name&&re.current.isValid){const r=z(p);M(r,e.name,e.fields),xe(r)}}});return q.current&&re.current.isValid&&xe(),()=>{O.current.unsubscribe(),e.unsubscribe(),r.unsubscribe()}}),[]),{control:n.useMemo((()=>({register:Ee,isWatchAllRef:B,watchFieldsRef:x,getIsDirty:le,formStateSubjectRef:k,fieldArraySubjectRef:j,controllerSubjectRef:D,watchSubjectRef:O,watchInternal:Ae,fieldsRef:p,validFieldsRef:E,fieldsWithValidationRef:_,fieldArrayNamesRef:U,readFormStateRef:re,formStateRef:te,defaultValuesRef:R,fieldArrayDefaultValuesRef:S,unregister:Ve,shouldUnmountUnregister:u})),[]),formState:C(N,$,re),trigger:we,register:Ee,handleSubmit:Re,watch:n.useCallback(((e,r)=>ce(e)?O.current.subscribe({next:t=>e(Ae(void 0,r),t)}):Ae(e,r,!0)),[]),setValue:n.useCallback(((e,r,t={})=>{A.current=!0;const n=m(p.current,e),a=U.current.has(e);a&&(j.current.next({fields:r,name:e,isReset:!0}),(re.current.isDirty||re.current.dirtyFields)&&t.shouldDirty&&(M(te.current.dirtyFields,e,K(r,m(R.current,e,[]),m(te.current.dirtyFields,e,[]))),k.current.next({dirtyFields:te.current.dirtyFields,isDirty:le(e,r)})),!r.length&&M(p.current,e,[])&&M(S.current,e,[])),n&&!n._f||a?ke(e,r,a?{}:t):ue(e,r,t,!0,!n),Oe(e)&&k.current.next({}),O.current.next({name:e,value:r})}),[ke]),getValues:n.useCallback(Se,[]),reset:n.useCallback(((e,r={})=>{const t=e||R.current;if(I&&!r.keepValues)for(const a of w.current){const e=m(p.current,a);if(e&&e._f){const r=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;if(ge(r))try{r.closest(\"form\").reset();break}catch(n){}}}!r.keepDefaultValues&&(R.current=Object.assign({},t)),r.keepValues||(p.current={},D.current.next({values:Object.assign({},t)}),O.current.next({value:Object.assign({},t)}),j.current.next({fields:Object.assign({},t),isReset:!0})),Ce(r,e)}),[]),clearErrors:n.useCallback((e=>{e&&(Array.isArray(e)?e:[e]).forEach((e=>X(te.current.errors,e))),k.current.next({errors:e?te.current.errors:{}})}),[]),unregister:n.useCallback(((e,r={})=>Ve(e,r,!0)),[]),setError:n.useCallback(((e,r,t)=>{const n=((m(p.current,e)||{_f:{}})._f||{}).ref;M(te.current.errors,e,Object.assign(Object.assign({},r),{ref:n})),k.current.next({errors:te.current.errors,isValid:!1}),t&&t.shouldFocus&&n&&n.focus&&n.focus()}),[]),setFocus:n.useCallback((e=>m(p.current,e)._f.ref.focus()),[])}}var ke=t(\"20a2\");function Oe(){return(Oe=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}var De=function(e){var r=e.type,t=e.label,n=e.name,s=e.required,i=e.pattern,c=e.minLength,o=E(),u=o.register,l=o.formState.errors;return a.a.createElement(\"div\",{className:\"grid grid-cols-1 gap-3\"},a.a.createElement(\"label\",{htmlFor:n},\" \",t,\" \"),a.a.createElement(\"input\",Oe({className:\"border-2 h-10 p-2\",id:n,name:n,type:r},u(n,{required:s&&s,pattern:i&&i,minLength:c&&c}))),l[n]&&a.a.createElement(\"span\",{className:\"text-red-500\",role:\"alert\"},l[n].message))},je=function(e){var r=e.children,t=e.type,n=void 0===t?\"button\":t;return a.a.createElement(\"button\",{type:n,className:\"bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\"},\" \",r,\" \")},Se=t(\"UtJu\"),xe=function(){var e=we(),r=Object(ke.useRouter)();return a.a.createElement(R,e,a.a.createElement(\"form\",{className:\"mx-auto self-center md:w-4/6 w-full p-20 grid grid-cols-1 gap-8 rounded overflow-hidden border-4 border-light-blue-500 border-opacity-25 shadow-lg\",onSubmit:e.handleSubmit((function(e){if(Se.d.emailId===e.emailID&&Se.d.password===e.password)return localStorage.setItem(\"accessToken\",Math.random().toString(36)),r.push(\"/dashboard\");alert(\"Login details incorrect\")}))},a.a.createElement(\"h1\",{className:\"mx-auto uppercase text-purple-500 font-bold\"},\" Haligonia Dance Academy \"),a.a.createElement(\"h2\",null,\" Enter Login Information: \"),a.a.createElement(De,{type:\"text\",label:\"Enter your Email ID\",name:\"emailID\",required:\"required\",pattern:{value:/\\S+@\\S+.\\S+/,message:\"Entered value does not match email format\"}}),a.a.createElement(De,{type:\"password\",label:\"Enter your Password\",name:\"password\",required:\"required\",minLength:{value:5,message:\"min length is 5\"}}),a.a.createElement(je,{type:\"submit\"},\" Continue \")))};r.default=function(){return React.createElement(s,null,React.createElement(\"div\",{className:\"grid xl:grid-cols-2  h-screen\"},React.createElement(\"div\",{className:\"imgbackground\"}),React.createElement(xe,null)))}},UtJu:function(e,r,t){\"use strict\";t.d(r,\"a\",(function(){return n})),t.d(r,\"d\",(function(){return a})),t.d(r,\"c\",(function(){return s})),t.d(r,\"b\",(function(){return i}));var n=[{id:1111,imageSrc:\"ballet-dance\",name:\"Ballet Dance\",bio:\"Ballet dance has its origin from Italy. The term ballet means to \\u201cdance.\\u201d This is usually accepted all over the world as one of the most artistic forms of entertainment enjoyed by all ages. This Dance is the combination of choreography and art, scenic design, lighting, costume, graceful movements with light classical music. These days the traditional ballet dance is replaced with new modern forms of ballet dance styles. Some of the forms of ballet dance are classical ballet, contemporary ballet, neoclassical ballet etc. This type of Dance is not difficult to learn once you have identified your passion for it.\"},{id:1113,imageSrc:\"kathak-dance\",name:\"Kathak Dance\",bio:\"In types of Indian Dance, Kathak is one which originated in the north Indian land. Among the many dance name list, Kathak is one beautiful form of art. Nomadic bards of ancient Northern India are known to lay down the foundation of this dance form. They were known as storyteller or Kathakars. The performers usually wear the famous Lehenga Choli costume while dancing. Even the copper bells used in Bharatnatyam are used in this dance form.\"},{id:1114,imageSrc:\"break-dance\",name:\"Break Dance\",bio:\"Breakdance also knew as a street dance was originated by Puerto Rican Youths and African Americans. This dance form consists of four major movements \\u2013 power moves, down rock, top rock and freezes. This is a modern kind of Dance that involves abstract body steps, that may or may not convey anything. It is usually practiced by the youth.\"},{id:1115,imageSrc:\"lion-dance\",name:\"Lion Dance\",bio:\"The lion dance is the traditional dance form of Chinese culture. In this form of dance, the performers wear lion costumes and mimic the moves and styles of a lion. This type of Dance is amazing to look at and is completely different from another dance form because you usually cannot see the person behind the costume in this form.\"},{id:1116,imageSrc:\"tap-dance\",name:\"Tap Dance\",bio:\"In this dance form, one needs to tap the shoes on the wooden floor. The shoes are made up of a metallic sole on the heel and the toe facilitating the tapping sound. The two well-known tap dance types are Broadway tap and Rhythmic tap. Tap dancing is also done in Cappella style in which performers need to perform on music created from tapping.\"},{id:1117,imageSrc:\"salsa-dance\",name:\"Salsa Dance\",bio:\"It will come in another type of western Dance which almost everyone knows and is performed all around the world. Salsa was originated in New York due to the strong influences of Latin America. Arms are used by the lead dancers to communicate with the followers. In these types of dances, the major expressive movements are done by the lower part of the body that is the hips, the body and legs. The upper body remains at its level. Salsa can be performed in different styles which can be identified on the basis of foot patterns, turns and figures, on the basis of timing, body rolls, dance influence, attitude and the way the partners hold each other while dancing.\"},{id:1118,imageSrc:\"waltz-dance\",name:\"Waltz Dance\",bio:\"The ballroom couple dance performed in closed positions is known as Waltz. This dance form had originated in the country of England during 1816. Several Victorian novels have the mentioning and a perfect description of this dance form. While dancing, the man is required to clasp his arms around his female partner\\u2019s waist. This type of modern Dance requires performers to execute delicate and fluid moves and Dance to slow melodic music.\"},{id:1119,imageSrc:\"belly-dance\",name:\"Belly Dance\",bio:\"One of the unique forms of Dance is belly dancing, and it comes under types of modern Dance. It is characterized by sharp and rolling movements of the abdomen and the hips. This dance form has different types of dance moves depending upon the region and country it is being performed. Movements of the hips and the torso communicate the maximum. Shakira, a famous Latin American superstar, was the one to popularize this form during the 2000s.\"},{id:1120,imageSrc:\"swing-dance\",name:\"Swing Dance\",bio:\"Swing, as the name sounds, is a very interesting dance form. It is a group of dances developed with a swing style danced to the tunes of jazz music during the 1920s \\u2013 1950s. Swing is a blanket word to different dances such as Jitterbugs, Boogie Woogie and Lindy hops. This type of dance form is fun, and the performers wear stylish dresses, yet very comfortable.\"},{id:1121,imageSrc:\"aerial-dance\",name:\"Aerial Dance\",bio:\"Aerial Dance is slowly becoming very famous these days. This dance form is not easy to perform and requires proper training. It was first performed in the USA during the 1970s. The name clearly indicates that in this form, the performer is required to perform in the air. The dancer hangs from any apparatus which is attached to the ceiling and performs steps in mid-air. It provides a lot of space to develop a new idea and dance moves.\"},{id:1122,imageSrc:\"tango-dance\",name:\"Tango Dance\",bio:\"It is a partner dance originated along with the river Plate during the 1890s the partners in tango follow each other chest to chest with either an open embrace or a closed embrace with a constant touch from the thigh area. Tango is a kind of ballroom dance and began in the working-class port in Uruguay, Argentina and Rio de la Plata.\"},{id:1123,imageSrc:\"disco-dance\",name:\"Disco Dance\",bio:\"Disco dance is a type of dance style that is a musical style dating to early 1970s. It began from the USA urban night-life scene, where it had been restricted to house parties. From there on, it began making regular mainstream appearances and gathered popularity. Its popularity was achieved sometime during the mid-1970s to the early 1980s.\"},{id:1124,imageSrc:\"folk-dance\",name:\"Fold Dance\",bio:\"Folk dance is a typical form of Dance that is usually extensively performed in rural areas. It talks of the folklore of the village plight. It is a traditional type of Dance pertaining to one set of people or community. The costumes are interesting and usually depict the traditional dress of the community.\"},{id:1112,imageSrc:\"bharata_Natyam_dance\",name:\"BharataNatyam Dance\",bio:\"Bharatnatyam is an Indian classical dance form having its origin in Tamil Nadu. It is a dance form practiced by both males and females. It is known among all for its tenderness of graceful expressions and posses and beauty of the dance steps. Dancers wear anklets while performing which consists of numerous copper bells attached. Dancers must excel in the art of perfect ringing of bells in the anklets and must also have proper control over it. Bharatnatyam is one of the well-known types of Dance in India.\"},{id:1125,imageSrc:\"electronic-dance\",name:\"Electronic Dance\",bio:\"This style of Dance is also known as Electronic Dance Music (EDM). This style started in Northern Europe during the 2000s and has become very popular in the next decades. This Dance is typically performed to electro house music based on different dance styles like disco, hip hop and freehand glow sticking.\"}],a={emailId:\"joedoe@yopmail.com\",password:\"JoeDoe@12345\"},s=[{name:\"Home\",href:\"/\",current:!0},{name:\"Login\",href:\"/login\",current:!1}],i=[{name:\"Logout\",href:\"/\",current:!0,event:!0}]},u6Hu:function(e,r,t){(window.__NEXT_P=window.__NEXT_P||[]).push([\"/login\",function(){return t(\"O2ls\")}])}},[[\"u6Hu\",0,2,1]]]);","map":{"version":3,"sources":["static/chunks/pages/login-67efd22bf09b2ff1ff1d.js"],"names":["_N_E","window","push","20a2","module","exports","__webpack_require__","O2ls","__webpack_exports__","r","react","react_default","n","Layout_PublicLayout","_ref","children","a","createElement","className","isCheckBoxInput","element","type","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","Date","getNodeParentName","name","substring","search","compact","filter","Boolean","isUndefined","val","undefined","get","obj","path","defaultValue","result","split","reduce","key","EVENTS","VALIDATION_MODE","UNDEFINED","INPUT_VALIDATION_RULES","omit","source","copy","Object","assign","FormContext","displayName","useFormContext","FormProvider","props","Provider","getProxyFormState","isProxyEnabled","formState","readFormStateRef","localReadFormStateRef","isRoot","Proxy","prop","current","isEmptyObject","keys","length","shouldRenderFormState","find","isWeb","HTMLElement","document","appendErrors","validateAllFieldCriteria","errors","message","types","[object Object]","isKey","test","stringToPath","input","replace","set","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","field","_f","ref","focus","refs","getFieldsValues","fieldsRef","defaultValuesRef","output","disabled","every","isPrimitive","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","deepMerge","target","targetValue","sourceValue","_a","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","setFieldArrayDirtyFields","slice","isBoolean","unset","updatePath","childObject","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","data","getFields","fieldsRefs","currentFields","isFileInput","isMultipleSelect","isRadioInput","defaultResult","isValid","validResult","getCheckboxValue","options","option","checked","map","attributes","defaultReturn","getRadioValue","previous","getFieldValue","files","selected","valueAsNumber","valueAsDate","setValueAs","NaN","getFieldValueAs","hasValidation","required","min","max","maxLength","minLength","pattern","validate","isFunction","isString","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","async","inputValue","error","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateRef","validateError","validationResult","validateFunction","entries","getValidationModes","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","isHTMLElement","Subscription","this","tearDowns","tearDown","teardown","Subscriber","observer","subscription","closed","add","next","Subject","observers","subscriber","isWindowUndefined","useForm","reValidateMode","resolver","context","shouldFocusError","shouldUnregister","criteriaMode","fieldsNamesRef","Set","formStateSubjectRef","watchSubjectRef","controllerSubjectRef","fieldArraySubjectRef","fieldArrayDefaultValuesRef","watchFieldsRef","isMountedRef","fieldsWithValidationRef","validFieldsRef","isWatchAllRef","contextRef","resolverRef","fieldArrayNamesRef","validationMode","isValidateAllFieldCriteria","setFormState","isDirty","isValidating","isSubmitted","submitCount","touchedFields","isSubmitting","isSubmitSuccessful","formStateRef","getIsValid","shouldRenderBaseOnError","shouldRender","state","isWatched","previousError","shouldReRender","updatedFormState","setFieldValue","rawValue","shouldRegister","register","forEach","radioRef","selectRef","includes","checkboxRef","shouldDirty","updateAndGetDirtyState","shouldValidate","trigger","getIsDirty","formValues","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","names","currentNames","validateForm","fieldError","Promise","all","setInternalValues","inputKey","fieldName","isFieldWatched","has","updateValidAndValue","isWithinRefCallback","defaultChecked","then","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","isTouched","skipValidation","previousFormIsValid","parentNodeName","currentError","getValues","fieldNames","updateIsValid","previousIsValid","watchInternal","isGlobal","isArrayNames","fieldValues","unregisterInternal","notify","inputName","delete","keepIsValid","keepError","keepValue","keepDirty","keepTouched","keepDefaultValue","registerFieldRef","isRadioOrCheckboxFunction","contains","isInitialRegister","onChange","onBlur","handleSubmit","onValid","onInvalid","e","preventDefault","persist","resetFromState","keepErrors","keepIsSubmitted","keepSubmitCount","formStateSubscription","subscribe","useFieldArraySubscription","unsubscribe","control","unregister","shouldUnmountUnregister","watch","info","setValue","isFieldArray","isReset","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","keepDefaultValues","clearErrors","setError","shouldFocus","setFocus","next_router","_extends","i","arguments","prototype","hasOwnProperty","call","apply","common_InputText_InputText","label","methods","htmlFor","id","role","Button_PrimaryButton","_ref$type","utils","components_LoginForm_LoginForm","router","onSubmit","emailId","emailID","password","localStorage","setItem","Math","random","toString","alert","React","UtJu","d","danceFormsLists","userData","navigation","dashboardNav","imageSrc","bio","href","event","u6Hu","__NEXT_P"],"mappings":"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"},"name":"static/chunks/pages/login-67efd22bf09b2ff1ff1d.js","input":"_N_E =\n(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[9],{\n\n/***/ \"20a2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"nOHt\")\n\n\n/***/ }),\n\n/***/ \"O2ls\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(\"q1tI\");\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// CONCATENATED MODULE: ./src/components/Layout/PublicLayout.js\n //login page layout\n\nvar PublicLayout_PublicLayout = function PublicLayout(_ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/react_default.a.createElement(\"div\", {\n    className: \"mx-auto grid gap-4\"\n  }, children);\n};\n\n/* harmony default export */ var Layout_PublicLayout = (PublicLayout_PublicLayout);\n// CONCATENATED MODULE: ./node_modules/react-hook-form/dist/index.esm.js\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = react[\"createContext\"](null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => react[\"useContext\"](FormContext);\r\nconst FormProvider = (props) => (react[\"createElement\"](FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formState, readFormStateRef, isRoot) => isEmptyObject(formState) ||\r\n    Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n    Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n        (isRoot ? VALIDATION_MODE.all : true));\n\nvar isWeb = typeof window !== UNDEFINED &&\r\n    typeof window.HTMLElement !== UNDEFINED &&\r\n    typeof document !== UNDEFINED;\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = (props && props.control) || methods.control;\r\n    const [formState, updateFormState] = react[\"useState\"](formStateRef.current);\r\n    const readFormState = react[\"useRef\"]({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    react[\"useEffect\"](() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => {\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\r\n            },\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, fieldArrayNamesRef, controllerSubjectRef, shouldUnmountUnregister, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const [value, setInputStateValue] = react[\"useState\"](isUndefined(get(fieldsRef.current, name)._f.value) ||\r\n        isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n    });\r\n    get(fieldsRef.current, name)._f.value = value;\r\n    react[\"useEffect\"](() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        ref({\r\n            target: value,\r\n        });\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            (shouldUnmountUnregister || shouldUnregister) && unregister(name);\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        formState,\r\n        fieldState: Object.defineProperties({}, {\r\n            invalid: {\r\n                get() {\r\n                    return !!get(formState.errors, name);\r\n                },\r\n            },\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touchedFields, name);\r\n                },\r\n            },\r\n            error: {\r\n                get() {\r\n                    return get(formState.errors, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, defaultValuesRef = { current: {} }, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            if (current) {\r\n                getFieldsValues({\r\n                    current,\r\n                }, defaultValuesRef, output[name]);\r\n            }\r\n        }\r\n    }\r\n    return Object.assign(Object.assign({}, defaultValuesRef.current), output);\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!react[\"isValidElement\"](object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...(Array.isArray(value) ? value : [value])];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value]), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = react[\"useRef\"]('');\r\n    const { isWatchAllRef, watchFieldsRef, getIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, unregister, shouldUnmountUnregister, } = control || methods.control;\r\n    const [fields, setFields] = react[\"useState\"](mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n        : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => (Array.isArray(index) ? index : [index]).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value,\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    react[\"useEffect\"](() => {\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, []),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    react[\"useEffect\"](() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            (shouldUnmountUnregister || shouldUnregister) && unregister(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: react[\"useCallback\"](swap, [name]),\r\n        move: react[\"useCallback\"](move, [name]),\r\n        prepend: react[\"useCallback\"](prepend$1, [name]),\r\n        append: react[\"useCallback\"](append$1, [name]),\r\n        remove: react[\"useCallback\"](remove, [name]),\r\n        insert: react[\"useCallback\"](insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => valueAsNumber\r\n    ? value === ''\r\n        ? NaN\r\n        : +value\r\n    : valueAsDate\r\n        ? new Date(value)\r\n        : setValueAs\r\n            ? setValueAs(value)\r\n            : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar hasValidation = (options) => options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isString = (value) => typeof value === 'string';\n\nvar isMessage = (value) => isString(value) || react[\"isValidElement\"](value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, }, }, validateAllFieldCriteria) => {\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = false, criteriaMode, } = {}) {\r\n    const fieldsRef = react[\"useRef\"]({});\r\n    const fieldsNamesRef = react[\"useRef\"](new Set());\r\n    const formStateSubjectRef = react[\"useRef\"](new Subject());\r\n    const watchSubjectRef = react[\"useRef\"](new Subject());\r\n    const controllerSubjectRef = react[\"useRef\"](new Subject());\r\n    const fieldArraySubjectRef = react[\"useRef\"](new Subject());\r\n    const fieldArrayDefaultValuesRef = react[\"useRef\"]({});\r\n    const watchFieldsRef = react[\"useRef\"](new Set());\r\n    const isMountedRef = react[\"useRef\"](false);\r\n    const fieldsWithValidationRef = react[\"useRef\"]({});\r\n    const validFieldsRef = react[\"useRef\"]({});\r\n    const defaultValuesRef = react[\"useRef\"](defaultValues);\r\n    const isWatchAllRef = react[\"useRef\"](false);\r\n    const contextRef = react[\"useRef\"](context);\r\n    const resolverRef = react[\"useRef\"](resolver);\r\n    const fieldArrayNamesRef = react[\"useRef\"](new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = react[\"useState\"]({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = react[\"useRef\"]({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = react[\"useRef\"](formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => (formStateRef.current.isValid =\r\n        deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n            isEmptyObject(formStateRef.current.errors));\r\n    const shouldRenderBaseOnError = react[\"useCallback\"]((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        let shouldReRender = shouldRender ||\r\n            !deepEqual(previousError, error, true) ||\r\n            (readFormStateRef.current.isValid &&\r\n                isUndefined(error) &&\r\n                get(fieldsWithValidationRef.current, name) &&\r\n                !get(validFieldsRef.current, name));\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            isWatched) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = react[\"useCallback\"]((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const _f = get(fieldsRef.current, name, {})._f;\r\n        if (_f) {\r\n            const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                ? ''\r\n                : rawValue;\r\n            _f.value = rawValue;\r\n            if (isRadioInput(_f.ref)) {\r\n                (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n            }\r\n            else if (isFileInput(_f.ref) && !isString(value)) {\r\n                _f.ref.files = value;\r\n            }\r\n            else if (isMultipleSelect(_f.ref)) {\r\n                [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n            }\r\n            else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                _f.refs.length > 1\r\n                    ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                        ? !!value.find((data) => data === checkboxRef.value)\r\n                        : value === checkboxRef.value))\r\n                    : (_f.refs[0].checked = !!value);\r\n            }\r\n            else {\r\n                _f.ref.value = value;\r\n            }\r\n            if (shouldRender) {\r\n                const values = getFieldsValues(fieldsRef);\r\n                set(values, name, rawValue);\r\n                controllerSubjectRef.current.next({\r\n                    values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                    name,\r\n                });\r\n            }\r\n            options.shouldDirty && updateAndGetDirtyState(name, value);\r\n            options.shouldValidate && trigger(name);\r\n        }\r\n    }, []);\r\n    const getIsDirty = react[\"useCallback\"]((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateAndGetDirtyState = react[\"useCallback\"]((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = react[\"useCallback\"](async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = react[\"useCallback\"](async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = react[\"useCallback\"](async (name) => {\r\n        const fields = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : Array.isArray(name)\r\n                ? name\r\n                : [name];\r\n        let isValid;\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name)\r\n                ? undefined\r\n                : fields));\r\n        }\r\n        else {\r\n            isUndefined(name)\r\n                ? await validateForm(fieldsRef.current)\r\n                : await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValidating: false,\r\n            isValid: resolverRef.current ? isValid : getIsValid(),\r\n        });\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = react[\"useCallback\"]((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        field && !field._f\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const defaultValue = isUndefined(field._f.value)\r\n            ? get(defaultValuesRef.current, name)\r\n            : field._f.value;\r\n        if (field && !isUndefined(defaultValue)) {\r\n            if (ref && ref.defaultChecked) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if ((!isUndefined(defaultValue) || isWithinRefCallback) &&\r\n            hasValidation(options) &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid !== getIsValid() &&\r\n                    setFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        isMountedRef.current = true;\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        (field && !field._f) || isFieldArray\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, value });\r\n    };\r\n    const handleChange = react[\"useCallback\"](async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f) && !resolverRef.current) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        value: inputValue,\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? {} : state));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    value: inputValue,\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = isMountedRef.current\r\n            ? getFieldsValues(fieldsRef, defaultValuesRef)\r\n            : defaultValuesRef.current;\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = react[\"useCallback\"](async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => unset(formStateRef.current.errors, inputName));\r\n        formStateSubjectRef.current.next({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = react[\"useCallback\"]((fieldNames, defaultValue, isGlobal) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = isMountedRef.current\r\n            ? getValues()\r\n            : isUndefined(defaultValue)\r\n                ? defaultValuesRef.current\r\n                : isArrayNames\r\n                    ? defaultValue || {}\r\n                    : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregisterInternal = (name, options = {}, notify) => {\r\n        for (const inputName of name\r\n            ? Array.isArray(name)\r\n                ? name\r\n                : [name]\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\r\n                notify &&\r\n                    watchSubjectRef.current.next({\r\n                        name: inputName,\r\n                    });\r\n            }\r\n        }\r\n        if (notify) {\r\n            formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n            !options.keepIsValid && updateIsValid();\r\n        }\r\n    };\r\n    const unregister = (name, options = {}) => unregisterInternal(name, options, true);\r\n    const registerFieldRef = (name, ref, options) => {\r\n        let field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n            if (ref === field._f.ref ||\r\n                (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n                (isRadioOrCheckbox &&\r\n                    Array.isArray(field._f.refs) &&\r\n                    compact(field._f.refs).find((option) => option === ref))) {\r\n                return;\r\n            }\r\n            field = {\r\n                _f: isRadioOrCheckbox\r\n                    ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                            ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                            ref,\r\n                        ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n            };\r\n            set(fieldsRef.current, name, field);\r\n            const defaultValue = updateValidAndValue(name, options, ref, true);\r\n            if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n                ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n                : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n                get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n            }\r\n        }\r\n    };\r\n    const register = react[\"useCallback\"]((name, options) => {\r\n        const isInitialRegister = !get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (isInitialRegister\r\n                ? { ref: { name } }\r\n                : Object.assign({ ref: (get(fieldsRef.current, name)._f || {}).ref }, get(fieldsRef.current, name)._f))), { name }), options),\r\n        });\r\n        hasValidation(options) &&\r\n            set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        isInitialRegister && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => ref\r\n                    ? registerFieldRef(name, ref, options)\r\n                    : (shouldUnregister || (options && options.shouldUnregister)) &&\r\n                        unregisterInternal(name),\r\n            };\r\n    }, [defaultValuesRef.current]);\r\n    const handleSubmit = react[\"useCallback\"]((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = react[\"useCallback\"](({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepIsValid, keepSubmitCount, }, values) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : !!(values && getIsDirty()),\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !!updateIsValid(values),\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of fieldsNamesRef.current) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                value: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        resetFromState(keepStateOptions, values);\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    react[\"useEffect\"](() => {\r\n        isMountedRef.current = true;\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState = {}) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    setFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        control: react[\"useMemo\"](() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            watchFieldsRef,\r\n            getIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            unregister: unregisterInternal,\r\n            shouldUnmountUnregister: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: react[\"useCallback\"](watch, []),\r\n        setValue: react[\"useCallback\"](setValue, [setInternalValues]),\r\n        getValues: react[\"useCallback\"](getValues, []),\r\n        reset: react[\"useCallback\"](reset, []),\r\n        clearErrors: react[\"useCallback\"](clearErrors, []),\r\n        unregister: react[\"useCallback\"](unregister, []),\r\n        setError: react[\"useCallback\"](setError, []),\r\n        setFocus: react[\"useCallback\"](setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = react[\"useRef\"](name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = react[\"useState\"](isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    react[\"useEffect\"](() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, value }) => (!nameRef.current ||\r\n                !inputName ||\r\n                (Array.isArray(nameRef.current)\r\n                    ? nameRef.current\r\n                    : [nameRef.current]).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(isString(inputName) &&\r\n                    nameRef.current === inputName &&\r\n                    !isUndefined(value)\r\n                    ? value\r\n                    : watchInternal(nameRef.current, defaultValue)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n// EXTERNAL MODULE: ./node_modules/next/router.js\nvar next_router = __webpack_require__(\"20a2\");\n\n// CONCATENATED MODULE: ./src/components/common/InputText/InputText.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n //Reusuable input text component\n\nvar InputText_InputText = function InputText(_ref) {\n  var type = _ref.type,\n      label = _ref.label,\n      name = _ref.name,\n      required = _ref.required,\n      pattern = _ref.pattern,\n      minLength = _ref.minLength;\n  var methods = useFormContext();\n  var register = methods.register,\n      errors = methods.formState.errors;\n  return /*#__PURE__*/react_default.a.createElement(\"div\", {\n    className: \"grid grid-cols-1 gap-3\"\n  }, /*#__PURE__*/react_default.a.createElement(\"label\", {\n    htmlFor: name\n  }, \" \", label, \" \"), /*#__PURE__*/react_default.a.createElement(\"input\", _extends({\n    className: \"border-2 h-10 p-2\",\n    id: name,\n    name: name,\n    type: type\n  }, register(name, {\n    required: required && required,\n    pattern: pattern && pattern,\n    minLength: minLength && minLength\n  }))), errors[name] && /*#__PURE__*/react_default.a.createElement(\"span\", {\n    className: \"text-red-500\",\n    role: \"alert\"\n  }, errors[name].message));\n};\n\n/* harmony default export */ var common_InputText_InputText = (InputText_InputText);\n// CONCATENATED MODULE: ./src/components/common/Button/PrimaryButton.js\n // resuable button component  \n\nvar PrimaryButton_PrimaryButton = function PrimaryButton(_ref) {\n  var children = _ref.children,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"button\" : _ref$type;\n  return /*#__PURE__*/react_default.a.createElement(\"button\", {\n    type: type,\n    className: \"bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\"\n  }, \" \", children, \" \");\n};\n\n/* harmony default export */ var Button_PrimaryButton = (PrimaryButton_PrimaryButton);\n// EXTERNAL MODULE: ./src/utlis/utils.js\nvar utils = __webpack_require__(\"UtJu\");\n\n// CONCATENATED MODULE: ./src/components/LoginForm/LoginForm.js\n\n\n\n\n\n\n\nvar LoginForm_LoginForm = function LoginForm() {\n  var methods = useForm();\n  var router = Object(next_router[\"useRouter\"])();\n\n  var onSubmit = function onSubmit(data) {\n    //comparing the Form login information with hardcoded user information\n    if (utils[\"d\" /* userData */].emailId === data.emailID && utils[\"d\" /* userData */].password === data.password) {\n      //IF true set the localstorage token\n      localStorage.setItem('accessToken', Math.random().toString(36));\n      return router.push('/dashboard');\n    } else {\n      alert(\"Login details incorrect\");\n    }\n  };\n\n  return /*#__PURE__*/react_default.a.createElement(FormProvider, methods, /*#__PURE__*/react_default.a.createElement(\"form\", {\n    className: \"mx-auto self-center md:w-4/6 w-full p-20 grid grid-cols-1 gap-8 rounded overflow-hidden border-4 border-light-blue-500 border-opacity-25 shadow-lg\",\n    onSubmit: methods.handleSubmit(onSubmit)\n  }, /*#__PURE__*/react_default.a.createElement(\"h1\", {\n    className: \"mx-auto uppercase text-purple-500 font-bold\"\n  }, \" Haligonia Dance Academy \"), /*#__PURE__*/react_default.a.createElement(\"h2\", null, \" Enter Login Information: \"), /*#__PURE__*/react_default.a.createElement(common_InputText_InputText, {\n    type: \"text\",\n    label: \"Enter your Email ID\",\n    name: \"emailID\",\n    required: \"required\",\n    pattern: {\n      value: /\\S+@\\S+.\\S+/,\n      message: \"Entered value does not match email format\"\n    }\n  }), /*#__PURE__*/react_default.a.createElement(common_InputText_InputText, {\n    type: \"password\",\n    label: \"Enter your Password\",\n    name: \"password\",\n    required: \"required\",\n    minLength: {\n      value: 5,\n      message: \"min length is 5\"\n    }\n  }), /*#__PURE__*/react_default.a.createElement(Button_PrimaryButton, {\n    type: \"submit\"\n  }, \" Continue \")));\n};\n\n/* harmony default export */ var components_LoginForm_LoginForm = (LoginForm_LoginForm);\n// CONCATENATED MODULE: ./pages/login.js\n\n\n\nfunction Page() {\n  return /*#__PURE__*/React.createElement(Layout_PublicLayout, null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"grid xl:grid-cols-2  h-screen\"\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"imgbackground\"\n  }), /*#__PURE__*/React.createElement(components_LoginForm_LoginForm, null)));\n}\n\n/* harmony default export */ var login = __webpack_exports__[\"default\"] = (Page);\n\n/***/ }),\n\n/***/ \"UtJu\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return danceFormsLists; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return userData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return navigation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return dashboardNav; });\n// Dance form Lists\nvar danceFormsLists = [{\n  id: 1111,\n  imageSrc: 'ballet-dance',\n  name: 'Ballet Dance',\n  bio: 'Ballet dance has its origin from Italy. The term ballet means to dance. This is usually accepted all over the world as one of the most artistic forms of entertainment enjoyed by all ages. This Dance is the combination of choreography and art, scenic design, lighting, costume, graceful movements with light classical music. These days the traditional ballet dance is replaced with new modern forms of ballet dance styles. Some of the forms of ballet dance are classical ballet, contemporary ballet, neoclassical ballet etc. This type of Dance is not difficult to learn once you have identified your passion for it.'\n}, {\n  id: 1113,\n  imageSrc: 'kathak-dance',\n  name: 'Kathak Dance',\n  bio: 'In types of Indian Dance, Kathak is one which originated in the north Indian land. Among the many dance name list, Kathak is one beautiful form of art. Nomadic bards of ancient Northern India are known to lay down the foundation of this dance form. They were known as storyteller or Kathakars. The performers usually wear the famous Lehenga Choli costume while dancing. Even the copper bells used in Bharatnatyam are used in this dance form.'\n}, {\n  id: 1114,\n  imageSrc: 'break-dance',\n  name: 'Break Dance',\n  bio: 'Breakdance also knew as a street dance was originated by Puerto Rican Youths and African Americans. This dance form consists of four major movements  power moves, down rock, top rock and freezes. This is a modern kind of Dance that involves abstract body steps, that may or may not convey anything. It is usually practiced by the youth.'\n}, {\n  id: 1115,\n  imageSrc: 'lion-dance',\n  name: 'Lion Dance',\n  bio: 'The lion dance is the traditional dance form of Chinese culture. In this form of dance, the performers wear lion costumes and mimic the moves and styles of a lion. This type of Dance is amazing to look at and is completely different from another dance form because you usually cannot see the person behind the costume in this form.'\n}, {\n  id: 1116,\n  imageSrc: 'tap-dance',\n  name: 'Tap Dance',\n  bio: 'In this dance form, one needs to tap the shoes on the wooden floor. The shoes are made up of a metallic sole on the heel and the toe facilitating the tapping sound. The two well-known tap dance types are Broadway tap and Rhythmic tap. Tap dancing is also done in Cappella style in which performers need to perform on music created from tapping.'\n}, {\n  id: 1117,\n  imageSrc: 'salsa-dance',\n  name: 'Salsa Dance',\n  bio: 'It will come in another type of western Dance which almost everyone knows and is performed all around the world. Salsa was originated in New York due to the strong influences of Latin America. Arms are used by the lead dancers to communicate with the followers. In these types of dances, the major expressive movements are done by the lower part of the body that is the hips, the body and legs. The upper body remains at its level. Salsa can be performed in different styles which can be identified on the basis of foot patterns, turns and figures, on the basis of timing, body rolls, dance influence, attitude and the way the partners hold each other while dancing.'\n}, {\n  id: 1118,\n  imageSrc: 'waltz-dance',\n  name: 'Waltz Dance',\n  bio: 'The ballroom couple dance performed in closed positions is known as Waltz. This dance form had originated in the country of England during 1816. Several Victorian novels have the mentioning and a perfect description of this dance form. While dancing, the man is required to clasp his arms around his female partners waist. This type of modern Dance requires performers to execute delicate and fluid moves and Dance to slow melodic music.'\n}, {\n  id: 1119,\n  imageSrc: 'belly-dance',\n  name: 'Belly Dance',\n  bio: 'One of the unique forms of Dance is belly dancing, and it comes under types of modern Dance. It is characterized by sharp and rolling movements of the abdomen and the hips. This dance form has different types of dance moves depending upon the region and country it is being performed. Movements of the hips and the torso communicate the maximum. Shakira, a famous Latin American superstar, was the one to popularize this form during the 2000s.'\n}, {\n  id: 1120,\n  imageSrc: 'swing-dance',\n  name: 'Swing Dance',\n  bio: 'Swing, as the name sounds, is a very interesting dance form. It is a group of dances developed with a swing style danced to the tunes of jazz music during the 1920s  1950s. Swing is a blanket word to different dances such as Jitterbugs, Boogie Woogie and Lindy hops. This type of dance form is fun, and the performers wear stylish dresses, yet very comfortable.'\n}, {\n  id: 1121,\n  imageSrc: 'aerial-dance',\n  name: 'Aerial Dance',\n  bio: 'Aerial Dance is slowly becoming very famous these days. This dance form is not easy to perform and requires proper training. It was first performed in the USA during the 1970s. The name clearly indicates that in this form, the performer is required to perform in the air. The dancer hangs from any apparatus which is attached to the ceiling and performs steps in mid-air. It provides a lot of space to develop a new idea and dance moves.'\n}, {\n  id: 1122,\n  imageSrc: 'tango-dance',\n  name: 'Tango Dance',\n  bio: 'It is a partner dance originated along with the river Plate during the 1890s the partners in tango follow each other chest to chest with either an open embrace or a closed embrace with a constant touch from the thigh area. Tango is a kind of ballroom dance and began in the working-class port in Uruguay, Argentina and Rio de la Plata.'\n}, {\n  id: 1123,\n  imageSrc: 'disco-dance',\n  name: 'Disco Dance',\n  bio: 'Disco dance is a type of dance style that is a musical style dating to early 1970s. It began from the USA urban night-life scene, where it had been restricted to house parties. From there on, it began making regular mainstream appearances and gathered popularity. Its popularity was achieved sometime during the mid-1970s to the early 1980s.'\n}, {\n  id: 1124,\n  imageSrc: 'folk-dance',\n  name: 'Fold Dance',\n  bio: 'Folk dance is a typical form of Dance that is usually extensively performed in rural areas. It talks of the folklore of the village plight. It is a traditional type of Dance pertaining to one set of people or community. The costumes are interesting and usually depict the traditional dress of the community.'\n}, {\n  id: 1112,\n  imageSrc: 'bharata_Natyam_dance',\n  name: 'BharataNatyam Dance',\n  bio: 'Bharatnatyam is an Indian classical dance form having its origin in Tamil Nadu. It is a dance form practiced by both males and females. It is known among all for its tenderness of graceful expressions and posses and beauty of the dance steps. Dancers wear anklets while performing which consists of numerous copper bells attached. Dancers must excel in the art of perfect ringing of bells in the anklets and must also have proper control over it. Bharatnatyam is one of the well-known types of Dance in India.'\n}, {\n  id: 1125,\n  imageSrc: 'electronic-dance',\n  name: 'Electronic Dance',\n  bio: 'This style of Dance is also known as Electronic Dance Music (EDM). This style started in Northern Europe during the 2000s and has become very popular in the next decades. This Dance is typically performed to electro house music based on different dance styles like disco, hip hop and freehand glow sticking.'\n}]; // User Login Details\n\nvar userData = {\n  emailId: 'joedoe@yopmail.com',\n  password: 'JoeDoe@12345'\n}; //Nav items for Landing page\n\nvar navigation = [{\n  name: 'Home',\n  href: '/',\n  current: true\n}, {\n  name: 'Login',\n  href: '/login',\n  current: false\n}]; //Nav items for Dashboard\n\nvar dashboardNav = [{\n  name: 'Logout',\n  href: '/',\n  current: true,\n  event: true\n}];\n\n/***/ }),\n\n/***/ \"u6Hu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/login\",\n      function () {\n        return __webpack_require__(\"O2ls\");\n      }\n    ]);\n  \n\n/***/ })\n\n},[[\"u6Hu\",0,2,1]]]);","inputSourceMap":{"version":3,"sources":["/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/router.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/src/components/Layout/PublicLayout.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/react-hook-form/dist/index.esm.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/src/components/common/InputText/InputText.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/src/components/common/Button/PrimaryButton.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/src/components/LoginForm/LoginForm.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/pages/login.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--4!/Users/rowengracious/DroneInsurance/my-test-app/src/utlis/utils.js","/Users/rowengracious/DroneInsurance/my-test-app/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Flogin&absolutePagePath=private-next-pages%2Flogin.js!"],"names":[],"mappings":";;;;;;AAAA,iBAAiB,mBAAO,CAAC,MAAsB;;;;;;;;;;;;;;;;;ACArB;;AAE1B,IAAI,yBAAY;AAChB;AACA,sBAAsB,eAAK;AAC3B;AACA,GAAG;AACH;;AAEe,iFAAY,E;;ACTI;;AAE/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,oBAAoB,sBAAmB;AACvC;AACA,6BAA6B,mBAAgB;AAC7C,iCAAiC,sBAAmB,wBAAwB,iCAAiC;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,sDAAsD;AACjE,yCAAyC,iBAAc;AACvD,0BAA0B,eAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,kBAAe;AACnB;AACA;AACA;AACA,kEAAkE;AAClE,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,wBAAwB,wDAAwD;AAChF;AACA,WAAW,wHAAwH;AACnI,WAAW,wBAAwB;AACnC,wCAAwC,iBAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,kBAAe;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,YAAY,EAAE,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,6EAA6E,uDAAuD;;AAEpI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mDAAmD;AAC3E;AACA,yBAAyB,eAAY;AACrC,WAAW,oSAAoS;AAC/S,gCAAgC,iBAAc;AAC9C;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,4HAA4H;AAC5H;AACA;AACA;AACA,iBAAiB,KAAK,GAAG,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB,KAAK,GAAG,MAAM;AACvC,aAAa,KAAK,GAAG,MAAM;AAC3B,gIAAgI,KAAK,EAAE,qCAAqC,aAAa,EAAE;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,mBAAmB,GAAG,6CAA6C,GAAG,IAAI;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,kBAAe;AACnB;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,IAAI,kBAAe;AACnB;AACA,kBAAkB,6CAA6C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,oBAAiB;AAC/B,cAAc,oBAAiB;AAC/B,iBAAiB,oBAAiB;AAClC,gBAAgB,oBAAiB;AACjC,gBAAgB,oBAAiB;AACjC,gBAAgB,oBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wDAAwD,OAAO;;AAE/D;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,8CAA8C,uBAAoB;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,MAAM,kHAAkH,GAAG;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC,+FAA+F,QAAQ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kHAAkH,oEAAoE,KAAK;AAC7M,sBAAsB,eAAY,GAAG;AACrC,2BAA2B,eAAY;AACvC,gCAAgC,eAAY;AAC5C,4BAA4B,eAAY;AACxC,iCAAiC,eAAY;AAC7C,iCAAiC,eAAY;AAC7C,uCAAuC,eAAY,GAAG;AACtD,2BAA2B,eAAY;AACvC,yBAAyB,eAAY;AACrC,oCAAoC,eAAY,GAAG;AACnD,2BAA2B,eAAY,GAAG;AAC1C,6BAA6B,eAAY;AACzC,0BAA0B,eAAY;AACtC,uBAAuB,eAAY;AACnC,wBAAwB,eAAY;AACpC,+BAA+B,eAAY;AAC3C;AACA;AACA,sCAAsC,iBAAc;AACpD;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL,6BAA6B,eAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,eAAY;AACrC;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAiB,+CAA+C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW,+FAA+F;AAC7K,iEAAiE;AACjE,2DAA2D;AAC3D;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,0BAA0B,oBAAiB,8BAA8B;AACzE;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,oBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL,mCAAmC,oBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,oBAAiB;AAC/C;AACA;AACA;AACA,KAAK;AACL,8CAA8C,oBAAiB;AAC/D,eAAe,SAAS;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,8BAA8B,oBAAiB;AAC/C,6BAA6B,KAAK,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B,wBAAwB;AACjH,aAAa;AACb;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,mEAAmE;AACnE,sCAAsC,cAAc;AACpD;AACA,yBAAyB,oBAAiB,SAAS,wBAAwB,yBAAyB,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkE;AACrF;AACA,8CAA8C;AAC9C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mEAAmE;AACnE;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAiB,mBAAmB;AAC9D;AACA;AACA,mBAAmB,SAAS,2DAA2D;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA,uDAAuD,OAAO,EAAE,UAAU;AAC1E,6EAA6E,WAAW,MAAM;AAC9F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,oBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yFAAyF,iDAAiD,IAAI,wBAAwB,6BAA6B,IAAI,wBAAwB;AAC/N;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,iCAAiC,uBAAuB,EAAE,kCAAkC,cAAc,MAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAiB;AACtC;AACA;AACA,4DAA4D;AAC5D,mBAAmB,OAAO,OAAO;AACjC,iCAAiC,4CAA4C,OAAO,uCAAuC,OAAO;AAClI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,oBAAiB;AAC1C;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,2BAA2B,oBAAiB,GAAG,qFAAqF;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,gFAAgF;AAChF,iEAAiE;AACjE;AACA;AACA,SAAS;AACT,KAAK;AACL,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,wCAAwC;AACxC,aAAa;AACb;AACA,uCAAuC;AACvC,aAAa;AACb;AACA,wCAAwC;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,IAAI,kBAAe;AACnB;AACA;AACA,+BAA+B;AAC/B;AACA,yEAAyE;AACzE;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,gBAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,oBAAiB;AAChC,kBAAkB,oBAAiB;AACnC,mBAAmB,oBAAiB;AACpC,eAAe,oBAAiB;AAChC,qBAAqB,oBAAiB;AACtC,oBAAoB,oBAAiB;AACrC,kBAAkB,oBAAiB;AACnC,kBAAkB,oBAAiB;AACnC;AACA;;AAEA;AACA,WAAW,8BAA8B;AACzC;AACA,oBAAoB,eAAY;AAChC;AACA,WAAW,iCAAiC;AAC5C,iCAAiC,iBAAc;AAC/C;AACA;AACA,IAAI,kBAAe;AACnB;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAE2I;AAC3I;;;;;;AC5nDA,qBAAqB,gDAAgD,gBAAgB,sBAAsB,OAAO,2BAA2B,0BAA0B,yDAAyD,2BAA2B,EAAE,EAAE,EAAE,eAAe,GAAG,wCAAwC;;AAEjS;AACuB;;AAEjD,IAAI,mBAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,sBAAsB,eAAK;AAC3B;AACA,GAAG,eAAe,eAAK;AACvB;AACA,GAAG,iCAAiC,eAAK;AACzC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG,kCAAkC,eAAK;AAC1C;AACA;AACA,GAAG;AACH;;AAEe,kFAAS,E;;AClCE;;AAE1B,IAAI,2BAAa;AACjB;AACA;AACA;AACA,sBAAsB,eAAK;AAC3B;AACA;AACA,GAAG;AACH;;AAEe,oFAAa,E;;;;;ACZF;AAC8B;AAChB;AACc;AACK;AACd;;AAE7C,IAAI,mBAAS;AACb,gBAAgB,OAAO;AACvB,eAAe,gCAAS;;AAExB;AACA;AACA,QAAQ,yBAAQ,6BAA6B,yBAAQ;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sBAAsB,eAAK,eAAe,YAAY,wBAAwB,eAAK;AACnF;AACA;AACA,GAAG,eAAe,eAAK;AACvB;AACA,GAAG,6CAA6C,eAAK,uEAAuE,eAAK,eAAe,0BAAS;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,gBAAgB,eAAK,eAAe,0BAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,gBAAgB,eAAK,eAAe,oBAAa;AACpD;AACA,GAAG;AACH;;AAEe,sFAAS,E;;AClDyC;AACH;;AAE9D;AACA,0CAA0C,mBAAY;AACtD;AACA,GAAG;AACH;AACA,GAAG,oCAAoC,8BAAS;AAChD;;AAEe,+EAAI,E;;;;;;;;ACXnB;AAAA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEI;AACP;AACA;AACA,EAAE;;AAEK;AACP;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC,EAAE;;AAEI;AACP;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;ACjGD;AACA;AACA;AACA,eAAe,mBAAO,CAAC,MAA6B;AACpD;AACA","file":"x","sourcesContent":["module.exports = require('./dist/client/router')\n","import React from 'react'; //login page layout\n\nvar PublicLayout = function PublicLayout(_ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"mx-auto grid gap-4\"\n  }, children);\n};\n\nexport default PublicLayout;","import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formState, readFormStateRef, isRoot) => isEmptyObject(formState) ||\r\n    Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n    Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n        (isRoot ? VALIDATION_MODE.all : true));\n\nvar isWeb = typeof window !== UNDEFINED &&\r\n    typeof window.HTMLElement !== UNDEFINED &&\r\n    typeof document !== UNDEFINED;\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = (props && props.control) || methods.control;\r\n    const [formState, updateFormState] = React.useState(formStateRef.current);\r\n    const readFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    React.useEffect(() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => {\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\r\n            },\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, fieldArrayNamesRef, controllerSubjectRef, shouldUnmountUnregister, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) ||\r\n        isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n    });\r\n    get(fieldsRef.current, name)._f.value = value;\r\n    React.useEffect(() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        ref({\r\n            target: value,\r\n        });\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            (shouldUnmountUnregister || shouldUnregister) && unregister(name);\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        formState,\r\n        fieldState: Object.defineProperties({}, {\r\n            invalid: {\r\n                get() {\r\n                    return !!get(formState.errors, name);\r\n                },\r\n            },\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touchedFields, name);\r\n                },\r\n            },\r\n            error: {\r\n                get() {\r\n                    return get(formState.errors, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, defaultValuesRef = { current: {} }, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            if (current) {\r\n                getFieldsValues({\r\n                    current,\r\n                }, defaultValuesRef, output[name]);\r\n            }\r\n        }\r\n    }\r\n    return Object.assign(Object.assign({}, defaultValuesRef.current), output);\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!React.isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...(Array.isArray(value) ? value : [value])];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value]), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = React.useRef('');\r\n    const { isWatchAllRef, watchFieldsRef, getIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, unregister, shouldUnmountUnregister, } = control || methods.control;\r\n    const [fields, setFields] = React.useState(mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n        : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => (Array.isArray(index) ? index : [index]).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value,\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    React.useEffect(() => {\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, []),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            (shouldUnmountUnregister || shouldUnregister) && unregister(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: React.useCallback(swap, [name]),\r\n        move: React.useCallback(move, [name]),\r\n        prepend: React.useCallback(prepend$1, [name]),\r\n        append: React.useCallback(append$1, [name]),\r\n        remove: React.useCallback(remove, [name]),\r\n        insert: React.useCallback(insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => valueAsNumber\r\n    ? value === ''\r\n        ? NaN\r\n        : +value\r\n    : valueAsDate\r\n        ? new Date(value)\r\n        : setValueAs\r\n            ? setValueAs(value)\r\n            : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar hasValidation = (options) => options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isString = (value) => typeof value === 'string';\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, }, }, validateAllFieldCriteria) => {\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = false, criteriaMode, } = {}) {\r\n    const fieldsRef = React.useRef({});\r\n    const fieldsNamesRef = React.useRef(new Set());\r\n    const formStateSubjectRef = React.useRef(new Subject());\r\n    const watchSubjectRef = React.useRef(new Subject());\r\n    const controllerSubjectRef = React.useRef(new Subject());\r\n    const fieldArraySubjectRef = React.useRef(new Subject());\r\n    const fieldArrayDefaultValuesRef = React.useRef({});\r\n    const watchFieldsRef = React.useRef(new Set());\r\n    const isMountedRef = React.useRef(false);\r\n    const fieldsWithValidationRef = React.useRef({});\r\n    const validFieldsRef = React.useRef({});\r\n    const defaultValuesRef = React.useRef(defaultValues);\r\n    const isWatchAllRef = React.useRef(false);\r\n    const contextRef = React.useRef(context);\r\n    const resolverRef = React.useRef(resolver);\r\n    const fieldArrayNamesRef = React.useRef(new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = React.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = React.useRef(formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => (formStateRef.current.isValid =\r\n        deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n            isEmptyObject(formStateRef.current.errors));\r\n    const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        let shouldReRender = shouldRender ||\r\n            !deepEqual(previousError, error, true) ||\r\n            (readFormStateRef.current.isValid &&\r\n                isUndefined(error) &&\r\n                get(fieldsWithValidationRef.current, name) &&\r\n                !get(validFieldsRef.current, name));\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            isWatched) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const _f = get(fieldsRef.current, name, {})._f;\r\n        if (_f) {\r\n            const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                ? ''\r\n                : rawValue;\r\n            _f.value = rawValue;\r\n            if (isRadioInput(_f.ref)) {\r\n                (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n            }\r\n            else if (isFileInput(_f.ref) && !isString(value)) {\r\n                _f.ref.files = value;\r\n            }\r\n            else if (isMultipleSelect(_f.ref)) {\r\n                [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n            }\r\n            else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                _f.refs.length > 1\r\n                    ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                        ? !!value.find((data) => data === checkboxRef.value)\r\n                        : value === checkboxRef.value))\r\n                    : (_f.refs[0].checked = !!value);\r\n            }\r\n            else {\r\n                _f.ref.value = value;\r\n            }\r\n            if (shouldRender) {\r\n                const values = getFieldsValues(fieldsRef);\r\n                set(values, name, rawValue);\r\n                controllerSubjectRef.current.next({\r\n                    values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                    name,\r\n                });\r\n            }\r\n            options.shouldDirty && updateAndGetDirtyState(name, value);\r\n            options.shouldValidate && trigger(name);\r\n        }\r\n    }, []);\r\n    const getIsDirty = React.useCallback((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = React.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = React.useCallback(async (name) => {\r\n        const fields = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : Array.isArray(name)\r\n                ? name\r\n                : [name];\r\n        let isValid;\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name)\r\n                ? undefined\r\n                : fields));\r\n        }\r\n        else {\r\n            isUndefined(name)\r\n                ? await validateForm(fieldsRef.current)\r\n                : await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValidating: false,\r\n            isValid: resolverRef.current ? isValid : getIsValid(),\r\n        });\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        field && !field._f\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const defaultValue = isUndefined(field._f.value)\r\n            ? get(defaultValuesRef.current, name)\r\n            : field._f.value;\r\n        if (field && !isUndefined(defaultValue)) {\r\n            if (ref && ref.defaultChecked) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if ((!isUndefined(defaultValue) || isWithinRefCallback) &&\r\n            hasValidation(options) &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid !== getIsValid() &&\r\n                    setFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        isMountedRef.current = true;\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        (field && !field._f) || isFieldArray\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, value });\r\n    };\r\n    const handleChange = React.useCallback(async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f) && !resolverRef.current) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        value: inputValue,\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? {} : state));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    value: inputValue,\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = isMountedRef.current\r\n            ? getFieldsValues(fieldsRef, defaultValuesRef)\r\n            : defaultValuesRef.current;\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = React.useCallback(async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => unset(formStateRef.current.errors, inputName));\r\n        formStateSubjectRef.current.next({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = isMountedRef.current\r\n            ? getValues()\r\n            : isUndefined(defaultValue)\r\n                ? defaultValuesRef.current\r\n                : isArrayNames\r\n                    ? defaultValue || {}\r\n                    : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregisterInternal = (name, options = {}, notify) => {\r\n        for (const inputName of name\r\n            ? Array.isArray(name)\r\n                ? name\r\n                : [name]\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\r\n                notify &&\r\n                    watchSubjectRef.current.next({\r\n                        name: inputName,\r\n                    });\r\n            }\r\n        }\r\n        if (notify) {\r\n            formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n            !options.keepIsValid && updateIsValid();\r\n        }\r\n    };\r\n    const unregister = (name, options = {}) => unregisterInternal(name, options, true);\r\n    const registerFieldRef = (name, ref, options) => {\r\n        let field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n            if (ref === field._f.ref ||\r\n                (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n                (isRadioOrCheckbox &&\r\n                    Array.isArray(field._f.refs) &&\r\n                    compact(field._f.refs).find((option) => option === ref))) {\r\n                return;\r\n            }\r\n            field = {\r\n                _f: isRadioOrCheckbox\r\n                    ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                            ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                            ref,\r\n                        ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n            };\r\n            set(fieldsRef.current, name, field);\r\n            const defaultValue = updateValidAndValue(name, options, ref, true);\r\n            if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n                ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n                : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n                get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n            }\r\n        }\r\n    };\r\n    const register = React.useCallback((name, options) => {\r\n        const isInitialRegister = !get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (isInitialRegister\r\n                ? { ref: { name } }\r\n                : Object.assign({ ref: (get(fieldsRef.current, name)._f || {}).ref }, get(fieldsRef.current, name)._f))), { name }), options),\r\n        });\r\n        hasValidation(options) &&\r\n            set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        isInitialRegister && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => ref\r\n                    ? registerFieldRef(name, ref, options)\r\n                    : (shouldUnregister || (options && options.shouldUnregister)) &&\r\n                        unregisterInternal(name),\r\n            };\r\n    }, [defaultValuesRef.current]);\r\n    const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = React.useCallback(({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepIsValid, keepSubmitCount, }, values) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : !!(values && getIsDirty()),\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !!updateIsValid(values),\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of fieldsNamesRef.current) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                value: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        resetFromState(keepStateOptions, values);\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    React.useEffect(() => {\r\n        isMountedRef.current = true;\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState = {}) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    setFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        control: React.useMemo(() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            watchFieldsRef,\r\n            getIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            unregister: unregisterInternal,\r\n            shouldUnmountUnregister: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: React.useCallback(watch, []),\r\n        setValue: React.useCallback(setValue, [setInternalValues]),\r\n        getValues: React.useCallback(getValues, []),\r\n        reset: React.useCallback(reset, []),\r\n        clearErrors: React.useCallback(clearErrors, []),\r\n        unregister: React.useCallback(unregister, []),\r\n        setError: React.useCallback(setError, []),\r\n        setFocus: React.useCallback(setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, value }) => (!nameRef.current ||\r\n                !inputName ||\r\n                (Array.isArray(nameRef.current)\r\n                    ? nameRef.current\r\n                    : [nameRef.current]).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(isString(inputName) &&\r\n                    nameRef.current === inputName &&\r\n                    !isUndefined(value)\r\n                    ? value\r\n                    : watchInternal(nameRef.current, defaultValue)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport { useFormContext } from 'react-hook-form'; //Reusuable input text component\n\nvar InputText = function InputText(_ref) {\n  var type = _ref.type,\n      label = _ref.label,\n      name = _ref.name,\n      required = _ref.required,\n      pattern = _ref.pattern,\n      minLength = _ref.minLength;\n  var methods = useFormContext();\n  var register = methods.register,\n      errors = methods.formState.errors;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"grid grid-cols-1 gap-3\"\n  }, /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: name\n  }, \" \", label, \" \"), /*#__PURE__*/React.createElement(\"input\", _extends({\n    className: \"border-2 h-10 p-2\",\n    id: name,\n    name: name,\n    type: type\n  }, register(name, {\n    required: required && required,\n    pattern: pattern && pattern,\n    minLength: minLength && minLength\n  }))), errors[name] && /*#__PURE__*/React.createElement(\"span\", {\n    className: \"text-red-500\",\n    role: \"alert\"\n  }, errors[name].message));\n};\n\nexport default InputText;","import React from 'react'; // resuable button component  \n\nvar PrimaryButton = function PrimaryButton(_ref) {\n  var children = _ref.children,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"button\" : _ref$type;\n  return /*#__PURE__*/React.createElement(\"button\", {\n    type: type,\n    className: \"bg-transparent hover:bg-blue-500 text-blue-700 font-semibold hover:text-white py-2 px-4 border border-blue-500 hover:border-transparent rounded\"\n  }, \" \", children, \" \");\n};\n\nexport default PrimaryButton;","import React from 'react';\nimport { useForm, FormProvider } from 'react-hook-form';\nimport { useRouter } from 'next/router';\nimport InputText from '../common/InputText/InputText';\nimport PrimaryButton from '../common/Button/PrimaryButton';\nimport { userData } from '../../utlis/utils';\n\nvar LoginForm = function LoginForm() {\n  var methods = useForm();\n  var router = useRouter();\n\n  var onSubmit = function onSubmit(data) {\n    //comparing the Form login information with hardcoded user information\n    if (userData.emailId === data.emailID && userData.password === data.password) {\n      //IF true set the localstorage token\n      localStorage.setItem('accessToken', Math.random().toString(36));\n      return router.push('/dashboard');\n    } else {\n      alert(\"Login details incorrect\");\n    }\n  };\n\n  return /*#__PURE__*/React.createElement(FormProvider, methods, /*#__PURE__*/React.createElement(\"form\", {\n    className: \"mx-auto self-center md:w-4/6 w-full p-20 grid grid-cols-1 gap-8 rounded overflow-hidden border-4 border-light-blue-500 border-opacity-25 shadow-lg\",\n    onSubmit: methods.handleSubmit(onSubmit)\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    className: \"mx-auto uppercase text-purple-500 font-bold\"\n  }, \" Haligonia Dance Academy \"), /*#__PURE__*/React.createElement(\"h2\", null, \" Enter Login Information: \"), /*#__PURE__*/React.createElement(InputText, {\n    type: \"text\",\n    label: \"Enter your Email ID\",\n    name: \"emailID\",\n    required: \"required\",\n    pattern: {\n      value: /\\S+@\\S+.\\S+/,\n      message: \"Entered value does not match email format\"\n    }\n  }), /*#__PURE__*/React.createElement(InputText, {\n    type: \"password\",\n    label: \"Enter your Password\",\n    name: \"password\",\n    required: \"required\",\n    minLength: {\n      value: 5,\n      message: \"min length is 5\"\n    }\n  }), /*#__PURE__*/React.createElement(PrimaryButton, {\n    type: \"submit\"\n  }, \" Continue \")));\n};\n\nexport default LoginForm;","import PublicLayout from '../src/components/Layout/PublicLayout';\nimport LoginForm from '../src/components/LoginForm/LoginForm';\n\nfunction Page() {\n  return /*#__PURE__*/React.createElement(PublicLayout, null, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"grid xl:grid-cols-2  h-screen\"\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"imgbackground\"\n  }), /*#__PURE__*/React.createElement(LoginForm, null)));\n}\n\nexport default Page;","// Dance form Lists\nexport var danceFormsLists = [{\n  id: 1111,\n  imageSrc: 'ballet-dance',\n  name: 'Ballet Dance',\n  bio: 'Ballet dance has its origin from Italy. The term ballet means to dance. This is usually accepted all over the world as one of the most artistic forms of entertainment enjoyed by all ages. This Dance is the combination of choreography and art, scenic design, lighting, costume, graceful movements with light classical music. These days the traditional ballet dance is replaced with new modern forms of ballet dance styles. Some of the forms of ballet dance are classical ballet, contemporary ballet, neoclassical ballet etc. This type of Dance is not difficult to learn once you have identified your passion for it.'\n}, {\n  id: 1113,\n  imageSrc: 'kathak-dance',\n  name: 'Kathak Dance',\n  bio: 'In types of Indian Dance, Kathak is one which originated in the north Indian land. Among the many dance name list, Kathak is one beautiful form of art. Nomadic bards of ancient Northern India are known to lay down the foundation of this dance form. They were known as storyteller or Kathakars. The performers usually wear the famous Lehenga Choli costume while dancing. Even the copper bells used in Bharatnatyam are used in this dance form.'\n}, {\n  id: 1114,\n  imageSrc: 'break-dance',\n  name: 'Break Dance',\n  bio: 'Breakdance also knew as a street dance was originated by Puerto Rican Youths and African Americans. This dance form consists of four major movements  power moves, down rock, top rock and freezes. This is a modern kind of Dance that involves abstract body steps, that may or may not convey anything. It is usually practiced by the youth.'\n}, {\n  id: 1115,\n  imageSrc: 'lion-dance',\n  name: 'Lion Dance',\n  bio: 'The lion dance is the traditional dance form of Chinese culture. In this form of dance, the performers wear lion costumes and mimic the moves and styles of a lion. This type of Dance is amazing to look at and is completely different from another dance form because you usually cannot see the person behind the costume in this form.'\n}, {\n  id: 1116,\n  imageSrc: 'tap-dance',\n  name: 'Tap Dance',\n  bio: 'In this dance form, one needs to tap the shoes on the wooden floor. The shoes are made up of a metallic sole on the heel and the toe facilitating the tapping sound. The two well-known tap dance types are Broadway tap and Rhythmic tap. Tap dancing is also done in Cappella style in which performers need to perform on music created from tapping.'\n}, {\n  id: 1117,\n  imageSrc: 'salsa-dance',\n  name: 'Salsa Dance',\n  bio: 'It will come in another type of western Dance which almost everyone knows and is performed all around the world. Salsa was originated in New York due to the strong influences of Latin America. Arms are used by the lead dancers to communicate with the followers. In these types of dances, the major expressive movements are done by the lower part of the body that is the hips, the body and legs. The upper body remains at its level. Salsa can be performed in different styles which can be identified on the basis of foot patterns, turns and figures, on the basis of timing, body rolls, dance influence, attitude and the way the partners hold each other while dancing.'\n}, {\n  id: 1118,\n  imageSrc: 'waltz-dance',\n  name: 'Waltz Dance',\n  bio: 'The ballroom couple dance performed in closed positions is known as Waltz. This dance form had originated in the country of England during 1816. Several Victorian novels have the mentioning and a perfect description of this dance form. While dancing, the man is required to clasp his arms around his female partners waist. This type of modern Dance requires performers to execute delicate and fluid moves and Dance to slow melodic music.'\n}, {\n  id: 1119,\n  imageSrc: 'belly-dance',\n  name: 'Belly Dance',\n  bio: 'One of the unique forms of Dance is belly dancing, and it comes under types of modern Dance. It is characterized by sharp and rolling movements of the abdomen and the hips. This dance form has different types of dance moves depending upon the region and country it is being performed. Movements of the hips and the torso communicate the maximum. Shakira, a famous Latin American superstar, was the one to popularize this form during the 2000s.'\n}, {\n  id: 1120,\n  imageSrc: 'swing-dance',\n  name: 'Swing Dance',\n  bio: 'Swing, as the name sounds, is a very interesting dance form. It is a group of dances developed with a swing style danced to the tunes of jazz music during the 1920s  1950s. Swing is a blanket word to different dances such as Jitterbugs, Boogie Woogie and Lindy hops. This type of dance form is fun, and the performers wear stylish dresses, yet very comfortable.'\n}, {\n  id: 1121,\n  imageSrc: 'aerial-dance',\n  name: 'Aerial Dance',\n  bio: 'Aerial Dance is slowly becoming very famous these days. This dance form is not easy to perform and requires proper training. It was first performed in the USA during the 1970s. The name clearly indicates that in this form, the performer is required to perform in the air. The dancer hangs from any apparatus which is attached to the ceiling and performs steps in mid-air. It provides a lot of space to develop a new idea and dance moves.'\n}, {\n  id: 1122,\n  imageSrc: 'tango-dance',\n  name: 'Tango Dance',\n  bio: 'It is a partner dance originated along with the river Plate during the 1890s the partners in tango follow each other chest to chest with either an open embrace or a closed embrace with a constant touch from the thigh area. Tango is a kind of ballroom dance and began in the working-class port in Uruguay, Argentina and Rio de la Plata.'\n}, {\n  id: 1123,\n  imageSrc: 'disco-dance',\n  name: 'Disco Dance',\n  bio: 'Disco dance is a type of dance style that is a musical style dating to early 1970s. It began from the USA urban night-life scene, where it had been restricted to house parties. From there on, it began making regular mainstream appearances and gathered popularity. Its popularity was achieved sometime during the mid-1970s to the early 1980s.'\n}, {\n  id: 1124,\n  imageSrc: 'folk-dance',\n  name: 'Fold Dance',\n  bio: 'Folk dance is a typical form of Dance that is usually extensively performed in rural areas. It talks of the folklore of the village plight. It is a traditional type of Dance pertaining to one set of people or community. The costumes are interesting and usually depict the traditional dress of the community.'\n}, {\n  id: 1112,\n  imageSrc: 'bharata_Natyam_dance',\n  name: 'BharataNatyam Dance',\n  bio: 'Bharatnatyam is an Indian classical dance form having its origin in Tamil Nadu. It is a dance form practiced by both males and females. It is known among all for its tenderness of graceful expressions and posses and beauty of the dance steps. Dancers wear anklets while performing which consists of numerous copper bells attached. Dancers must excel in the art of perfect ringing of bells in the anklets and must also have proper control over it. Bharatnatyam is one of the well-known types of Dance in India.'\n}, {\n  id: 1125,\n  imageSrc: 'electronic-dance',\n  name: 'Electronic Dance',\n  bio: 'This style of Dance is also known as Electronic Dance Music (EDM). This style started in Northern Europe during the 2000s and has become very popular in the next decades. This Dance is typically performed to electro house music based on different dance styles like disco, hip hop and freehand glow sticking.'\n}]; // User Login Details\n\nexport var userData = {\n  emailId: 'joedoe@yopmail.com',\n  password: 'JoeDoe@12345'\n}; //Nav items for Landing page\n\nexport var navigation = [{\n  name: 'Home',\n  href: '/',\n  current: true\n}, {\n  name: 'Login',\n  href: '/login',\n  current: false\n}]; //Nav items for Dashboard\n\nexport var dashboardNav = [{\n  name: 'Logout',\n  href: '/',\n  current: true,\n  event: true\n}];","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/login\",\n      function () {\n        return require(\"private-next-pages/login.js\");\n      }\n    ]);\n  "]}}